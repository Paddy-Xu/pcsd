\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{listings}
\usepackage{tikz}
\usepackage{amsmath,amssymb}
\tikzset{main node/.style={circle,fill=white!20,draw,minimum size=1cm,inner sep=0pt},}
\usepackage{verbatim}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}

\begin{document}

\begin{center}
\textsc{\LARGE Principles of Computer System Design}\\[0.3cm] % Context
\HRule \\[0.4cm]
{ \huge \bfseries Assignment 3} % Main title
\HRule \\[0.4cm]
\large
Johannes de Fine Licht % Names
\\Philip Graae
\\Ola RÃ¸nning
\\\today
\end{center}
\section*{Recovery Concepts}
\subsection*{1.}
If a system implements force and no-stealing, the system will not have to implement \texttt{REDO} nor \texttt{UNDO}. The system will not have to implement \texttt{REDO} as the state of system is always consistent on the non-volatile memory, this is because writes are forced to write to the the non-volatile memory. As the system does not implement stealing; non-volatile storage will never have dirty cells, and hence there will be nothing to \texttt{UNDO} after a crash.
\subsection*{2.}
The difference between non-volatile and stable storage, is that stable storage can recover from media failure by implementing redundancy. Both kind of storage can recover from crashes. The final kind of storage, volatile storage, cannot recover from neither media failure nor crashes.
\subsection*{3.}
The two situations that will require the log tail to be forced to stable storage, are before a data page is written to non-volatile storage and when a transaction commits. The log tail must be forced to stable storage before a data page is written to ensure recoverability in case of a subsequent crash where the data page is lost. The log tail must furthermore be forced to stable storage when a transaction is committed to ensure the changes of a committed transaction can survive crashes. As volatile storage will not be recoverable from a crash, a record of the state of the system that the non-volatile storage represents after a crash is necessary. Hence to ensure the durability of the system, it is sufficient to maintain a record of state represented by the storage that will survive a crash, i.e. non-volatile storage.
\section*{ARIES}
\begin{table}[h!]
\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}lllll} 
\texttt{LOG}&&&& \\ 
&&&&\\ 
\texttt{LSN} & \texttt{LAST\_LSN} & \texttt{TRAN\_ID} & \texttt{TYPE} & \texttt{PAGE\_ID} \\
\texttt{1} & \texttt{-} & \texttt{-} & \texttt{begin CKPT} & \texttt{-} \\ 
\texttt{2} & \texttt{-} & \texttt{-} & \texttt{end CKPT} & \texttt{-} \\ 
\texttt{3} & \texttt{NULL} & \texttt{T1} & \texttt{update} & \texttt{P2} \\ 
\texttt{4} & \texttt{3} &\texttt{T1} & \texttt{update} & \texttt{P1} \\ 
\texttt{5} & \texttt{NULL} & \texttt{T2} & \texttt{update} & \texttt{P5} \\ 
\texttt{6} & \texttt{NULL} & \texttt{T3} & \texttt{update} & \texttt{P3} \\ 
\texttt{7} & \texttt{6} & \texttt{T3} & \texttt{commit} & \texttt{-} \\ 
\texttt{8} & \texttt{5} & \texttt{T2} & \texttt{update} & \texttt{P5} \\
\texttt{9} & \texttt{8} & \texttt{T2} & \texttt{update} & \texttt{P3} \\
\texttt{10} & \texttt{6} & \texttt{T3} & \texttt{END} & \texttt{-} \\ 
\end{tabular*}
\caption{The log of transaction before a crash.}
\label{log}
\end{table} 
\subsection*{1.}
\begin{table}[h!]
\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}lllll} 
\texttt{Transaction table}&&&& \\ 
&&&&\\ 
\texttt{TRAN\_ID} & \texttt{Status} & \texttt{last\_LSN} \\
\texttt{T1} & \texttt{progress} & \texttt{4} \\ 
\texttt{T2} & \texttt{progress} & \texttt{9} \\ 
\end{tabular*}
\caption{The transaction table after the crash, based on the log, see table~\ref{log}.}
\label{trans}
\end{table}
\begin{table}
\begin{tabular*}{\textwidth}{@{\extracolsep{\fill}}lllll} 
\texttt{Dirty page table}&&&& \\ 
&&&&\\ 
\texttt{Page\_ID} & \texttt{recLSN} \\
\texttt{P1} & \texttt{4}\\ 
\texttt{P2} & \texttt{3}\\ 
\texttt{P3} & \texttt{6}\\ 
\texttt{P5} & \texttt{5}\\
\end{tabular*}
\caption{The dirty page table after the crash, based on the log, see table~\ref{log}.}
\label{dirty}
\end{table}
The transaction table, see table~\ref{trans}, is based on the log, see table~\ref{log}. Transaction three has ended and hence is not on the Transaction table, whilst transaction one and two are still in progress, when the crash occurs.\\
The dirty page table, see table~\ref{dirty}, is based on the log, see table~\ref{log}. The \texttt{recLSN} field represents the first log sequence number identifying a update dirtying a particular page. Pages one, two three and five was written to after the last checkpoint where the dirty page table was flushed.
\subsection*{2.}
The set of winner transaction are transactions that have committed and ended before the crash occurs, whilst the loser set represents the transactions that are still in progress. Hence the winner set for the log, see table~\ref{log}, is \{\texttt{T3}\} and the losers set is \{\texttt{T1}, \texttt{T2}\}.
\subsection*{3.}
The redo phase will begin at LSN three as this is the lowest LSN recorded in the dirty page table. The undo phase will ended at LSN three, the highest LSN will be picked and after the modification it identifies is undone its \texttt{LAST\_LSN} will be added until all transaction recorded in the Transaction table have \texttt{NULL} recorded in their \texttt{LAST\_LSN} field.
\subsection*{4.}

\subsection*{5.}
\subsection*{6.}
\section*{Programming Task}
\section*{Discussion on the Performance Measurements}
\subsection*{1.}
\subsection*{2.}
\subsection*{3.}
\end{document}
